// Copyright 2023 Enrico Granata
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#[cfg(test)]
pub mod test;

pub mod ast;
pub mod bom;
pub mod builders;
pub mod codegen;
pub mod driver;
pub mod err;
pub mod iw;
pub mod mangler;
pub mod parser;

use std::path::PathBuf;

use iw::{CompilerOptions, OutputMode};

use clap::Parser;
#[derive(Clone, Parser, Debug)]
#[command(author, version, about="The CÂ± language", long_about = None)]
struct Args {
    #[arg(short, help = "Print out the LLVM IR generated by the compiler")]
    dump: bool,
    #[arg(short, help = "The output of the compilation")]
    output: Option<String>,
    #[arg(
        short = 'O',
        default_value_t = false,
        help = "Optimize the result of the compilation"
    )]
    optimize: bool,
    #[arg(
        long,
        required = false,
        default_value = "x86_64-pc-linux-gnu",
        help = "A specification of which target machine to compiler for"
    )]
    triple: String,
    #[arg(required = true, help = "One or more input files to process")]
    inputs: Vec<String>,
    #[arg(
        long,
        default_value_t = false,
        help = "Add debug statements to debug refcounting errors (ony useful if you're developing the compiler itself"
    )]
    instrument_refcount: bool,
    #[arg(
        long = "Werr",
        default_value_t = false,
        help = "Treat warnings as errors"
    )]
    warn_as_err: bool,
    #[arg(
        short = 'l',
        long = "link",
        help = "Additional libraries to link into the current target"
    )]
    link_extras: Vec<String>,
    #[arg(
        long = "bom",
        help = "Export a BOM so that the compiled unit can be imported elsewhere"
    )]
    bom: bool,
    #[arg(short = 'g', help = "Generate debug information (not implemented)")]
    debug: bool,
    #[arg(long = "jit", help = "Compile and run in a single shot")]
    jit: bool,
    #[arg(
        long = "compile",
        help = "Run the full compiler chain generating output files"
    )]
    compile: bool,
}

impl Args {
    fn to_codegen_options(&self) -> CompilerOptions {
        CompilerOptions {
            triple: self.triple.clone(),
            warn_as_err: self.warn_as_err,
            instrument_refcount: self.instrument_refcount,
            link_extras: self.link_extras.clone(),
            dump_ir_text: self.dump,
            dump_bom: self.bom,
            optimize: self.optimize,
            debug: self.debug,
            out: if self.jit || (self.inputs.len() == 1 && self.output.is_none() && !self.compile) {
                OutputMode::Jit
            } else {
                OutputMode::Binary
            },
        }
    }
}

pub fn main() {
    let args = Args::parse();

    if args.jit && args.compile {
        eprintln!("--jit and --compile are mutually exclusive");
        std::process::exit(1);
    }

    let inputs: Vec<PathBuf> = args.inputs.iter().map(PathBuf::from).collect();
    let options = args.to_codegen_options();

    if args.optimize && args.debug {
        eprintln!("cannot generate debug info in optimized builds");
        std::process::exit(1);
    }

    if options.out == OutputMode::Jit {
        let jit_result = driver::run_multi_jit(&inputs, &options);
        match jit_result.result {
            Ok(ret) => println!("main returned {ret}"),
            Err(msg) => println!("jit error: {msg}"),
        }
    } else if args.output.is_none() {
        let _ = driver::build_objects(&inputs, options);
    } else {
        let output = PathBuf::from(args.output.unwrap());
        let _ = driver::build_aout(&inputs, &output, options);
    }
}
